<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>프로그래밍 권장사항 | PEP8 한국어 번역</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="PEP8을 한국어로 번역한 결과물이 담겨있는 문서사이트입니다.">
    <meta name="theme-color" content="#59a1de">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/pep8-in-korean/assets/css/0.styles.9e9cce96.css" as="style"><link rel="preload" href="/pep8-in-korean/assets/js/app.a12a1249.js" as="script"><link rel="preload" href="/pep8-in-korean/assets/js/2.57dcf0f5.js" as="script"><link rel="preload" href="/pep8-in-korean/assets/js/18.15c4cf48.js" as="script"><link rel="prefetch" href="/pep8-in-korean/assets/js/10.ae9c76f3.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/11.70cdde76.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/12.b2097cf9.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/13.3c6da5a9.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/14.ac78824d.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/15.67cc85b2.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/16.a7a88eee.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/17.b61922ee.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/19.f45b3b6d.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/20.8573ab2c.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/21.6020ed7e.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/22.d523873b.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/23.c86af526.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/24.ce5b86b8.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/25.29631f68.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/26.af5904eb.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/27.6be267bd.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/28.d6f52613.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/29.1cbddcbd.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/3.c13f1c1c.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/30.c17e2e44.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/31.9ab3b0a1.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/32.8e43dca9.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/33.f2cfb98f.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/4.8f235c98.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/5.a62480a2.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/6.1b26c8d4.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/7.700b9f43.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/8.f34e5a63.js"><link rel="prefetch" href="/pep8-in-korean/assets/js/9.c08f58f3.js">
    <link rel="stylesheet" href="/pep8-in-korean/assets/css/0.styles.9e9cce96.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/pep8-in-korean/" class="home-link router-link-active"><!----> <span class="site-name">PEP8 한국어 번역</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/pep8-in-korean/docguide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/pep8-in-korean/doc/" class="nav-link router-link-active">
  Document
</a></div><div class="nav-item"><a href="/pep8-in-korean/hello/" class="nav-link">
  Hello
</a></div> <a href="https://github.com/zerosheepmoo/pep8-in-korean" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/pep8-in-korean/docguide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/pep8-in-korean/doc/" class="nav-link router-link-active">
  Document
</a></div><div class="nav-item"><a href="/pep8-in-korean/hello/" class="nav-link">
  Hello
</a></div> <a href="https://github.com/zerosheepmoo/pep8-in-korean" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>PEP8</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pep8-in-korean/doc/introduction.html" class="sidebar-link">소개</a></li><li><a href="/pep8-in-korean/doc/a-foolish-consistency-is-the-hobgoblin-of-little-minds.html" class="sidebar-link">각선구검(刻船求劍)</a></li><li><a href="/pep8-in-korean/doc/code-lay-out.html" class="sidebar-link">코드 레이아웃</a></li><li><a href="/pep8-in-korean/doc/code-lay-out-rest.html" class="sidebar-link">코드 레이아웃 나머지</a></li><li><a href="/pep8-in-korean/doc/string-quotes.html" class="sidebar-link">문자열 쿼트</a></li><li><a href="/pep8-in-korean/doc/whitespace-in-expressions-and-statements.html" class="sidebar-link">표현과 문장에서의 공백</a></li><li><a href="/pep8-in-korean/doc/when-to-use-trailing-commas.html" class="sidebar-link">후행 쉼표를 사용할 경우</a></li><li><a href="/pep8-in-korean/doc/comments.html" class="sidebar-link">주석</a></li><li><a href="/pep8-in-korean/doc/naming-conventions.html" class="sidebar-link">작명 컨벤션</a></li><li><a href="/pep8-in-korean/doc/programming-recommendations.html" aria-current="page" class="active sidebar-link">프로그래밍 권장사항</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pep8-in-korean/doc/programming-recommendations.html#함수-어노테이션" class="sidebar-link">함수 어노테이션</a></li><li class="sidebar-sub-header"><a href="/pep8-in-korean/doc/programming-recommendations.html#변수-어노테이션" class="sidebar-link">변수 어노테이션</a></li></ul></li><li><a href="/pep8-in-korean/doc/references.html" class="sidebar-link">참조</a></li><li><a href="/pep8-in-korean/doc/copyright.html" class="sidebar-link">Copyright</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="프로그래밍-권장사항"><a href="#프로그래밍-권장사항" class="header-anchor">#</a> 프로그래밍 권장사항</h1> <ul><li><p>코드는 Python 의 다른 구현들
(PyPy, Jython, IronPython, Cython, Psyco 등)
에 해가 되지 않는 방향으로
작성되어야 한다.</p> <p>예를 들면, <code>a += b</code> 또는 <code>a = a + b</code> 형식의 명령문에 대한
CPython의 효율적인 내부 문자열 연결(concatnation)
구현에 의존하지 말자.
이 최적화는 CPython 에서도 깨지기 쉽다.
(이는 몇 몇 타입에만 작동한다.)
그리고 이 최적화는 refcounting<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 을 사용하지 않는 구현에는 전혀 도입되지 않는다.
라이브러리의 성능에 민감한 부분에서는 <code>''.join ()</code> 형식을 대신 사용해야 한다.
이렇게 해야 다양한 구현에서 연결 구현이 선형 시간으로 발생한다.</p></li> <li><p><code>None</code> 같은 싱글톤과의 비교는 <code>is</code> 나 <code>is not</code> 으로 항상 이루어져야 한다.
등호 연산자는 절대 안된다.</p> <p>또, <code>if x</code> 를 작성할 때는 정말로 <code>if x is not None</code> 의 의미여야 한다.
None이 디폴트 값인 변수나 아규먼트가 다른 값으로
설정되어 있는지를 테스트 할 때 말이다.
그 다른 값은 (container 같이) boolean 컨텍스트에서
false 가 될 수 있는 타입을 갖고 있을 수 있다!</p></li> <li><p><code>is not</code> 연산자를 <code>not ... is</code>보다 더 사용하자.
둘 다 기능적으로는 동리하지만, 전자의 형식이 더 가독성 있고
바람직한 방식이다.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> foo <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> foo <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
</code></pre></div><ul><li><p>리치 연산자를 사용하여 연산자의 순서를 정하는 구현을 할 때,
여섯 개의 모든 연산자
(<code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code>)
를 구현하는 것이 가장 좋다. 특정 연산에서 작동하는 다른 코드에 의존하는 것보다 말이다.</p> <p>들어가는 노력을 최소화하기 위해, <code>functools.total_ordering()</code> 데코레이터는
누락된 비교 메소드를 생성하는 툴을 제공한다.</p> <p><a href="https://www.python.org/dev/peps/pep-0207/" target="_blank" rel="noopener noreferrer">PEP 207<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
은 반사성(reflexivity) 규칙이 Python 에 의해 <strong>가정</strong>됨을 나타낸다.
따라서, 인터프리터가 <code>y &gt; x</code> 를 <code>x &lt; y</code>로, <code>y &gt;= x</code> 를 <code>x &lt;= y</code>로
바꾸거나, <code>x == y</code> 와 <code>x != y</code>의 아규먼트(<em>역: 여기서는 양변</em>)을 바꿀 수 있다.
<code>sort()</code>와 <code>min()</code> 연산은 <code>&lt;</code> 연산자를 사용하는 것을,
<code>max()</code> 함수는 <code>&gt;</code> 연산자를 사용하는 것을 보장한다.
하지만, 다른 컨텍스트로부터 혼란이 떠오르지 않기 위해 여섯 개의 모든 연산들을 구현하는 것이 가장 바람직하다.</p></li> <li><p>식별자에 직접적으로 람다 표현식을 바인딩한 할당 문보다,
항상 <code>def</code> 문을 사용하자.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code>      <span class="token comment"># 옳은 예:</span>
      <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">*</span>x
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code>      <span class="token comment"># 틀린 예:</span>
      f <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">*</span>x
</code></pre></div><p>첫번째 형식은 결과 함수 객체 명을 제네릭
<code>&lt;lambda&gt;</code> 대신 구체적으로 'f'임을 의미한다.
이는 일반적인 문자열 표현(representation)과 역추적(tracebacks)에 있어
유용하다. 할당 문의 사용은 람다 표현식이 명시적인 <code>def</code> 선언문 없이 제공된다는
유일한 이점을 제거한다.
(즉, 이는 커다란 표현 안에서 내장될(embedded) 수 있다는 말.)</p> <ul><li><p>예외를 <code>BaseException</code>보다 <code>Exception</code>으로 부터 파생(derive)시키자.
<code>BaseException</code>으로 부터 직접적인 상속을 한 예외는
대게 항상 잘못된 짓을 했을 때 포착(catching)되는 예외가 있는 곳에서 사용될 것으로 예정되어있다.</p> <p>코드가 예외를 <em>포착</em>하는 데 필요한 구분(distictions)을
기반으로 예외 계층을 설계하자. 예외가 떠오르는(raised) 곳에서 하기보다는 말이다.
단순히 &quot;문제가 발생하였다.&quot;는 언급에 대하여 겨냥하기 보단,
프로그램적으로 &quot;무엇이 잘못 되어가고 있었나?&quot; 하는 질문에 대한 답을 겨냥하자.
(<a href="https://www.python.org/dev/peps/pep-3151/" target="_blank" rel="noopener noreferrer">PEP 3151<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
의 내장 예외 계층에 대해서 배우는수업의 예시를 참고하자.)</p> <p>비록 예외가 오류일 경우에는 접두어로 &quot;Error&quot;를 당신의 예외 클래스들에 추가하지만,
기본적으로 클래스 작명 컨벤션이 적용된다. 에러가 아닌 예외들은 특별한 접두어가
필요하지 않다. 이런 예외들은 비논리적인 흐름 제어거나
다른 신호전달(signaling)의 형태다.</p></li> <li><p>예외 체이닝을 적절히 사용하자. Python 3에서는 <code>raise X from Y</code>가
원래의 역추적(traceback)의 손실이 없이 명시적인 대체(<em>역: 예외 체이닝</em>)를 나타내는데
사용되어야한다.</p> <p>의도적으로 내부 예외를 대체하는 경우
(Python 2의 <code>raise X</code>, Python 3.3+의 <code>raise X from Y</code>를 사용하는 것),
관련 세부 사항이 새로운 예외로 양도(transferred)되었다는 것을 보장해야한다.
(예를 들어, KeyError를 AttributeError로
전환할 때 어트리뷰트 명이 보존되는 것
또는, 새로운 예외 메시지 안에서 원래 예외의 텍스트가 들어있는 것)</p></li> <li><p>Python 2 에서 예외가 떠오를 경우, <code>raise ValueError('message')</code>를 사용하자.
오래된 형식인 <code>raise ValueError, 'message'</code> 대신에 말이다.</p> <p>이 오래된 형식은 Python 3 문법에서는 허용하지 않는다.</p> <p>또한, 괄호 사용 양식(paren-using form)은 예외의 아규먼트가 길거나
문자열 포매팅을 포함할 때,
감싸는 소괄호 덕에 줄 이음 문자를 사용할 필요가 없어짐을 나타내기도 한다.</p></li> <li><p>예외를 포착할 때, 생 <code>except:</code> 절을 사용하기 보다
가능한 특정 예외를 언급하라.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> platform_specific_module
<span class="token keyword">except</span> ImportError<span class="token punctuation">:</span>
    platform_specific_module <span class="token operator">=</span> <span class="token boolean">None</span>
</code></pre></div><p>생 <code>except:</code> 절은 SystemExit 과 KeyboardInterrupt 예외를 포착할 것이며,
이로인해 컨트롤 + C 를 사용해서 프로그램을 중단하기 어렵게 만든다.
그리고 다른 문제로 가장(disguise)될 수도 있다.
(<em>역: 본래 문제에 대한 예외가 발생해야하는데 다른 문제로 인식될 수 있다는 것</em>)
프로그램 오류를 알리는 모든 예외를 포착하고 싶다면, <code>except Exception:</code>을 사용하자.
(생 예외처리는 <code>except BaseException:</code>과 같기 때문이다.)</p> <p>엄지척 할 수 있는 좋은 규칙은 생 <code>'except'</code> 절 사용을
다음 두 개의 경우로만 제한하는 것이다.</p> <ol><li>예외 핸들러가 역추적을 로깅하거나 출력하게 될 때.
최소한 사용자가 오류가 발생했음을 인지할 수 있도록.</li> <li>코드 정리(cleanup) 작업을 해야할 때. 하지만 그럴 땐 예외를 <code>raise</code>와 함께
위로 전파(propagate)하도록 하게하자.
이러한  경우를 제어하기 위해 <code>try..finally</code>
가 더 좋은 방법이 될 수 있다.</li></ol> <ul><li>포착된 예외를 이름에 바인딩할 때, Python 2.6 에서 추가된
명시적 이름 바인딩 구문이 바람직하다.</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    process_data<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
    <span class="token keyword">raise</span> DataProcessingFailedError<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>이는 Python 3에서만 지원되는 구문이다.
그리고 오래된 콤마 기반 구문과 구분하기 애매해지는 문제를 피하자.</p> <ul><li><p>운영체제 오류를 포착할 땐, Python 3.3 에서 도입된 명시적 예외 계층구조가 바람직하다.
<code>errno</code> 값들을 검사하는 것(introspection) 대신에 말이다.</p></li> <li><p>추가적으로 모든 try/except 절에 대해, <code>try</code> 절을
필요한 최소한의 코드로 제한하자. 다시 말하지만, 이는 마스킹 버그를 방지한다.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> collection<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
    <span class="token keyword">return</span> key_not_found<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> handle_value<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># 너무 범위가 넓다!</span>
    <span class="token keyword">return</span> handle_value<span class="token punctuation">(</span>collection<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
    <span class="token comment"># handle_value() 로 떠오른 KeyError 도 포착하게 될 것이다.</span>
    <span class="token keyword">return</span> key_not_found<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
</code></pre></div><ul><li><p>자원이 특정 구역의 코드에 국지적일 때,
<code>with</code> 문을 사용하여 즉시 정리됨과 사용 후 신뢰성(reliably)를 보장하자.
try/finally 문 또한 허용가능하다.</p></li> <li><p>컨텍스트 관리자는 자원을 획득하거나 해제하는 일 외의 작업을 할 때마다
별도의 함수 또는 메소드를 통해 불러와져야(invoked) 한다.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">with</span> conn<span class="token punctuation">.</span>begin_transaction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    do_stuff_in_transaction<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">with</span> conn<span class="token punctuation">:</span>
    do_stuff_in_transaction<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
</code></pre></div><p>후자의 예시는 <code>__enter__</code>와 <code>__exit__</code> 메소드가
트랜잭션(transaction) 후의 연결을 닫는 것 외에 어떤 작업을 수행하고 있음을
나타내는 어떠한 정보도 제공하지 않는다.
이 경우 명시적으로 하는 것이 중요하다.</p> <ul><li>반환 문에 대하여 일관성을 지키자.
함수 내 모든 반환 문은 표현을 반환하거나 어떤 것도 반환하지 않아야 한다.
만약 반환 문이 어떠한 표현을 반환한다면,
어떠한 반환문도 반환값이 없는 곳에서는 명시적으로 <code>return None</code>을 작성해야 한다.
그리고 명시적인 반환 문은 함수의 끝에 나타내야 한다.
(도달 가능(reachable)하다면 말이다.)</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>

<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>

<span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>

<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre></div><ul><li><p>문자열 모듈을 사용하는 것 대신에 문자열 메소드를 사용하자.</p> <p>문자열 메소드는 항상 더 빠르고 유니코드 문자열과 같은 API를 공유한다.
2.0 버전 이전의 Python과의 호환성이 필요한 경우, 이 규칙을 오버라이딩 하자.</p></li> <li><p>접두어나 접미어를 확인할 때는, 문자열 슬라이싱 대신에
<code>''.startswith()</code>와 <code>''.endswith()</code>를 사용하자.</p> <p><code>startswith()</code> 와 <code>endswith()</code>는 더 깔끕하고 더 적은 오류를 야기하는 경향이 있다.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> foo<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">if</span> foo<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'bar'</span><span class="token punctuation">:</span>
</code></pre></div><ul><li>오브젝트 타입 비교는 직접 비교하기 보단,</li> <li>항상 <code>isinstance()</code>를 사용해야한다.</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre></div><p>오브젝트가 문자열인지를 확인할 때는, 유니코드 문자열일 수도 있다는 점을 명심하자!
Python 2에서는 str과 유니코드가 공통적인 기반 클래스, basestring을 가진다.
그래서 다음과 같이 할 수도 있다.</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">basestring</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre></div><p>Python 3 에서는 더 이상 <code>unicode</code>와 <code>basestring</code>이 존재하지 않는 점을 알아두자.
(오직 <code>str</code>만이 있다.) 그리고 바이트 오브젝트는 더 이상 문자열 종류가 아니다.
(대신 정수형의 시퀀스(sequence of integers)가 되었다.)</p> <ul><li>시퀀스에 대해서는 (문자열, 리스트, 튜플), 빈 시퀀스가 false 라는 사실을 사용하자.</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> seq<span class="token punctuation">:</span>
<span class="token keyword">if</span> seq<span class="token punctuation">:</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre></div><ul><li><p>문자열 리터럴을 중요한 후행 공백에 의존하여 작성하지 말자.
그러한 후행 공백은 보기에 구분이 어렵고,
몇 에디터(또는 더 최근의, reindent,py)에서는 트림된다.</p></li> <li><p>불린 값을 <code>==</code>를 사용하여 True 또는 False 와 비교하지 말자.</p></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> greeting<span class="token punctuation">:</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">if</span> greeting <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
</code></pre></div><p>더 안 좋게는 다음과 같이 할 수 있다.</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">if</span> greeting <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
</code></pre></div><ul><li><code>return</code>/<code>break</code>/<code>continue</code>의 흐름 제어문이 finally 슈트 밖으로 점프될 수 있는
<code>try...finally</code>의 finally 슈트에서의 흐름 제어문들의 사용은 권장하지 않는다.
왜냐하면 이러한 명령문들은 finally 슈트를 통하여 전파된
어떤 활성화 된 예외도 암시적으로 취소할 수 있기 때문이다.</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 틀린 예:</span>
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">42</span>
</code></pre></div><h2 id="함수-어노테이션"><a href="#함수-어노테이션" class="header-anchor">#</a> 함수 어노테이션</h2> <blockquote><p><a href="/pep8-in-korean/doc/function-annotations.html">함수 어노테이션</a> 번역 후 합칠 예정</p></blockquote> <h2 id="변수-어노테이션"><a href="#변수-어노테이션" class="header-anchor">#</a> 변수 어노테이션</h2> <blockquote><p><a href="/pep8-in-korean/doc/variable-annotations.html">변수 어노테이션</a> 번역 후 합칠 예정</p></blockquote> <hr class="footnotes-sep"> <section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener noreferrer">참조 횟수 계산 방식<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/12/2021, 4:04:25 PM [KST]</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pep8-in-korean/doc/naming-conventions.html" class="prev">
        작명 컨벤션
      </a></span> <span class="next"><a href="/pep8-in-korean/doc/references.html">
        참조
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/pep8-in-korean/assets/js/app.a12a1249.js" defer></script><script src="/pep8-in-korean/assets/js/2.57dcf0f5.js" defer></script><script src="/pep8-in-korean/assets/js/18.15c4cf48.js" defer></script>
  </body>
</html>
