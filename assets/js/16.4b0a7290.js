(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{381:function(t,a,s){"use strict";s.r(a);var _=s(26),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"작명-컨벤션"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#작명-컨벤션"}},[t._v("#")]),t._v(" 작명 컨벤션")]),t._v(" "),s("p",[t._v("Python 라이브러리의 작명 컨벤션은 이미 정리가 안되어있다.\n그래서 앞으로도 절대 일관성있게 유지할 수가 없을 것이다.\n그럼에도 불구하고 이곳에 권장하는 작명 기준을 소개한다.\n새로운 모듈들과 패키지들(서드 파티 프레임워크 등을 포함하여)은 이 기준대로 작성해야한다.\n하지만 이미 존재하는 라이브러리에서 다른 스타일을 따르고 있다면\n내부의 일관성을 우선하자.("),s("em",[t._v("역: 그 라이브러리의 스타일들을 우선하자")]),t._v(")")]),t._v(" "),s("h2",{attrs:{id:"오버라이딩-컨벤션"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#오버라이딩-컨벤션"}},[t._v("#")]),t._v(" 오버라이딩 컨벤션")]),t._v(" "),s("p",[t._v("API의 공개 부분으로 사용자에게 표시되는 이름은\n구현보다는 사용법을 반영하는 컨벤션을 따르자.")]),t._v(" "),s("h2",{attrs:{id:"설명-작명-컨벤션"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#설명-작명-컨벤션"}},[t._v("#")]),t._v(" 설명: 작명 컨벤션")]),t._v(" "),s("blockquote",[s("p",[s("RouterLink",{attrs:{to:"/doc/descriptive-naming-styles.html"}},[t._v("설명: 작명 컨벤션")]),t._v(" 이 번역되면 채워질 예정")],1)]),t._v(" "),s("h2",{attrs:{id:"규정-작명-컨벤션"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#규정-작명-컨벤션"}},[t._v("#")]),t._v(" 규정: 작명 컨벤션")]),t._v(" "),s("h3",{attrs:{id:"피해야할-이름"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#피해야할-이름"}},[t._v("#")]),t._v(" 피해야할 이름")]),t._v(" "),s("p",[s("code",[t._v("l")]),t._v(" (소문자 엘), "),s("code",[t._v("O")]),t._v(" (대문자 오), "),s("code",[t._v("I")]),t._v(" (대문자 아이)는\n단독으로 변수명으로 절대 사용하지 마라.")]),t._v(" "),s("p",[t._v("몇 몇 폰트에서는 이글자들이 숫자 1, 0과 구분하기 어렵다.\n"),s("code",[t._v("l")]),t._v("을 쓰고 싶을 땐 "),s("code",[t._v("L")]),t._v("을 쓰자.")]),t._v(" "),s("h3",{attrs:{id:"ascii-호환성"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ascii-호환성"}},[t._v("#")]),t._v(" ASCII 호환성")]),t._v(" "),s("p",[t._v("표준 라이브러리에서 사용되는 식별자들은 반드시 ASCII 호환성을 따라야한다.\n"),s("a",{attrs:{href:"https://www.python.org/dev/peps/pep-3131",target:"_blank",rel:"noopener noreferrer"}},[t._v("PEP 3131"),s("OutboundLink")],1),t._v("의\n"),s("a",{attrs:{href:"https://www.python.org/dev/peps/pep-3131/#policy-specification",target:"_blank",rel:"noopener noreferrer"}},[t._v("정책 섹션"),s("OutboundLink")],1),t._v("\n에 설명된 것처럼 말이다.")]),t._v(" "),s("h3",{attrs:{id:"패키지와-모듈-명"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#패키지와-모듈-명"}},[t._v("#")]),t._v(" 패키지와 모듈 명")]),t._v(" "),s("p",[t._v("모듈 이름은 모두 소문자를 사용하여 짧게 지어야한다.\n밑줄(Underscores)은 가독성 향상을 위해 사용될 수 있다.")]),t._v(" "),s("p",[t._v("Python 패키지 이름은 모두 소문자를 사용하여 짧게 지어야한다. 단, 밑줄은 권장되지 않는다.")]),t._v(" "),s("p",[t._v("C 또는 C++ 로 쓰여진 확장모듈들이\n더 높은 레벨의 인터페이스를 제공하는\nPython 모듈(예를 들면, 더 객체 지향적인)을 동반할 경우,\nC/C++ 모듈들은 첫글자 밑줄 이름으로 짓는다. (예를 들면 "),s("code",[t._v("_socket")]),t._v(")")]),t._v(" "),s("h3",{attrs:{id:"클래스-명"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#클래스-명"}},[t._v("#")]),t._v(" 클래스 명")]),t._v(" "),s("p",[t._v("클래스 명들은 일반적으로 CapWords"),s("sup",{staticClass:"footnote-ref"},[s("a",{attrs:{href:"#fn1",id:"fnref1"}},[t._v("[1]")])]),t._v(" 컨벤션을 따른다.")]),t._v(" "),s("p",[t._v("인터페이스가 문서화되어 있고, 주로 Callable"),s("sup",{staticClass:"footnote-ref"},[s("a",{attrs:{href:"#fn2",id:"fnref2"}},[t._v("[2]")])]),t._v("로 사용되는 경우,\n함수의 작명 컨벤션을 따를 수 있다.")]),t._v(" "),s("p",[t._v("내장 된 클래스들과 컨벤션이 다른 것에 주목하자.\n대부분의 내장 된 클래스 명은 단일 단어 (또는 같이 실행되는 두개의 단어)다.\nCapWords 컨벤션은 예외(exception)의 이름이나 내장 상수에만 사용된다.")]),t._v(" "),s("h3",{attrs:{id:"타입-변수-명"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#타입-변수-명"}},[t._v("#")]),t._v(" 타입 변수 명")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.python.org/dev/peps/pep-0484/",target:"_blank",rel:"noopener noreferrer"}},[t._v("PEP484"),s("OutboundLink")],1),t._v(" 에서 소개된 타입 변수의 이름은\nCapWords 를 사용하여 짧게 짓는다. 예를들어, "),s("code",[t._v("T")]),t._v(", "),s("code",[t._v("AnyStr")]),t._v(", "),s("code",[t._v("Num")]),t._v(".\n"),s("code",[t._v("_co")]),t._v(" 나 "),s("code",[t._v("_contra")]),t._v(" 접두어를 공변(covariant)과 반변(contravariant)"),s("sup",{staticClass:"footnote-ref"},[s("a",{attrs:{href:"#fn3",id:"fnref3"}},[t._v("[3]")])]),t._v(" 행위를\n선언하기 위해 사용할 수 있다. 다음처럼 말이다.")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" typing "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" TypeVar\n\nVT_co "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" TypeVar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'VT_co'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" covariant"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nKT_contra "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" TypeVar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'KT_contra'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" contravariant"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"예외-명"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#예외-명"}},[t._v("#")]),t._v(" 예외 명")]),t._v(" "),s("p",[t._v("예외는 클래스기 때문에, "),s("a",{attrs:{href:"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%AA%85"}},[t._v("클래스 작명 컨벤션")]),t._v("을 적용한다.\n하지만 만약 예외가 실제로 오류일 경우("),s("em",[t._v("역: 오류와 같은 개념일 경우")]),t._v("),\n"),s("code",[t._v('"Error"')]),t._v(" 라는 접두어를 예외 명 앞에다 붙여야한다.")]),t._v(" "),s("h3",{attrs:{id:"전역-변수-명"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#전역-변수-명"}},[t._v("#")]),t._v(" 전역 변수 명")]),t._v(" "),s("p",[t._v("(이 변수들이 하나의 모듈 안에서만 있다고 가정하자)\n함수에 대한 컨벤션과 같다.")]),t._v(" "),s("p",[s("code",[t._v("from M import *")]),t._v(" 를 사용하기 위해 설계된 모듈들은\n"),s("code",[t._v("__all__")]),t._v(' 메커니즘을 사용하여 전역변수들을 내보내기 하는 것을 막아야한다.\n또는 밑줄을 접두어로 넣는 오래된 컨벤션을 사용하자.\n(이 전역 변수들이 "module non-public"'),s("sup",{staticClass:"footnote-ref"},[s("a",{attrs:{href:"#fn4",id:"fnref4"}},[t._v("[4]")])]),t._v("임을 나타내고 싶을 수 있을 때)")]),t._v(" "),s("p",[t._v("함수와 변수 명")]),t._v(" "),s("p",[t._v("함수 명은 소문자여야하며 가독성 향상을 위해\n밑줄로 단어를 구분해야한다.")]),t._v(" "),s("p",[t._v("변수 명도 함수 명과 같은 컨벤션을 따른다.")]),t._v(" "),s("p",[t._v("mixedCase"),s("sup",{staticClass:"footnote-ref"},[s("a",{attrs:{href:"#fn5",id:"fnref5"}},[t._v("[5]")])]),t._v(" 는 이미 스타일이 존재하는 컨텍스트에만\n(예를 들면 "),s("code",[t._v("threading.py")]),t._v(") 혀용된다.\n이는 이전 버전과의 호환성을 지키기위한 것이다.")]),t._v(" "),s("h3",{attrs:{id:"함수와-메소드의-아규먼트들"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#함수와-메소드의-아규먼트들"}},[t._v("#")]),t._v(" 함수와 메소드의 아규먼트들")]),t._v(" "),s("p",[t._v("항상 "),s("code",[t._v("self")]),t._v(" 를 인스턴스 메소드의 첫번째 아규먼트로 사용한다.")]),t._v(" "),s("p",[t._v("항상 "),s("code",[t._v("cls")]),t._v(" 를 클래스 메소드의 첫번째 아규먼트로 사용한다.")]),t._v(" "),s("p",[t._v("만약 함수의 아규먼트 명이 이미 있는 키워드와 충돌이 있을 경우,\n일반적으로 후행 밑줄을 추가하는 것이\n약어 또는 철자 손상을 사용하는 것보다 낫다.\n따라서 "),s("code",[t._v("class_")]),t._v("가 "),s("code",[t._v("clss")]),t._v(" 보다 낫다.\n(혹은 동의어등을 사용하여 이러한 충돌을 피하는 것이 더 나을 수 있다.)")]),t._v(" "),s("h3",{attrs:{id:"메소드-명과-인스턴스-변수"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#메소드-명과-인스턴스-변수"}},[t._v("#")]),t._v(" 메소드 명과 인스턴스 변수")]),t._v(" "),s("p",[t._v("함수 작명 규칙을 따르자.\n소문자를 사용하고 가독성 향상을 위해 단어 구분할 때 밑줄을 귿는 것 말이다.")]),t._v(" "),s("p",[t._v("첫글자만 밑줄인 단어는 non-public 인 메소드와 인스턴스 변수들을 위해서만 스여야한다.")]),t._v(" "),s("p",[t._v("하위 클래스들과의 이름 충돌을 피하기위해, 두 개의 밑줄로 시작하는 단어를 사용하여\nPython의 이름 맹글링"),s("sup",{staticClass:"footnote-ref"},[s("a",{attrs:{href:"#fn6",id:"fnref6"}},[t._v("[6]")])]),t._v(" 규칙을 불러오자(invoke).")]),t._v(" "),s("p",[t._v("Python 은 다음과 같이 이름들을 클래스 명과 함께 맹글한다.\n만약 클래스 "),s("code",[t._v("Foo")]),t._v(" 가 "),s("code",[t._v("__a")]),t._v(" 어트리뷰트를 갖고 있을 경우, "),s("code",[t._v("Foo.__a")]),t._v("로 접근할 수 없다.\n(필요한 사용자는 "),s("code",[t._v("Foo._Foo__a")]),t._v("를 호출하여 여전히 접근할 수는 있다.)\n일반적으로 두개의 밑줄만으로 시작하는 이름은 하위 클래스로 설계된 클래스 내의 어트리뷰트와\n이름 충돌을 피하는 용도로 사용된다.")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내")]),t._v(" "),s("p",[s("code",[t._v("__names")]),t._v(" 를 사용하는 것에 대해 논쟁이 있다. (아래를 참고하기).")])]),t._v(" "),s("h3",{attrs:{id:"상수"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#상수"}},[t._v("#")]),t._v(" 상수")]),t._v(" "),s("p",[t._v("상수는 주로 모듈 레벨에서 정의된다. 그리고 대문자로만 쓰여지며\n단어를 구분하기 위해 밑줄이 사용된다.\n예를 들면, "),s("code",[t._v("MAX_OVERFLOW")]),t._v("와 "),s("code",[t._v("TOTAL")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"상속을-고려한-설계"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#상속을-고려한-설계"}},[t._v("#")]),t._v(" 상속을 고려한 설계")]),t._v(" "),s("p",[t._v("항상 클래스 메소드와 인스턴스 변수(통칭: "),s("strong",[t._v('"어트리뷰트"')]),t._v(")\n가 퍼블릭인지 아닌지 결정하라.\n만약 결정되지 않았다면, 퍼블릭이 아닌 컨벤션을 골라라.\n나중에 퍼블릭으로 바꾸는 것이 퍼블릭을 아닌 것으로 바꾸는 것이 더 쉽다.")]),t._v(" "),s("p",[t._v("퍼블릭 어트리뷰트는 이전 버전과의 호환성을 유지하려는 노력과 함께,\n사용할 클래스의 클라이언트와 관계되지 않을 것을 예상하는 어트리뷰트다.\n퍼블릭이 아닌 어트리뷰트는 외부에서 사용되게끔 의도하지 않는 어트리뷰트다.\n그래서 퍼블릭이 아닌 어트리뷰트가 앞으로 바뀌거나 제거되지 않을 것이라는\n보장을 하지 말아야된다.")]),t._v(" "),s("p",[t._v('우리는 "프라이빗(private)"이라는 용어를 사용하지 않는다.\n왜냐하면 어떠한 어트리뷰트도 실제 Python 에서는 프라이빗일 수 없기 때문이다.(일반적으로 불필요한 양의 추가 작업 없이는)')]),t._v(" "),s("p",[t._v('어트리뷰트들의 다른 종류로는 "하위클래스 API"의 일부인 어트리뷰트가 있다.\n(자주 "protected"로 다른 언어에서 표현되는 어트리뷰트)\n몇 클래스는 클래스의 행위의 측면에서 확장 또는 수정(modify)하기 위해 상속되도록 설계되었다.\n그러한 클래스를 설계할 때는,\n어떤 어트리뷰트를 퍼블릭으로 하고, 어떤 부분을 하위클래스 API로 할 것이며,\n그리고 어떤 어트리뷰트를 진짜로 당신의 기반 클래스에서만 사용할 것인지\n명시적인 결정을 하는 것에 주의해야한다.')]),t._v(" "),s("p",[t._v("이를 명심하며, 다음의 Python 스러운 가이드라인을 살펴보자.")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("퍼블릭 어트리뷰트는 첫글자가 밑줄이면 안된다.")])]),t._v(" "),s("li",[s("p",[t._v("만약 퍼블릭 어트리뷰트 명이 이미 있던 키워드와 충돌하면,\n하나의 후행 밑줄을 어트리뷰트 명에 추가하자.\n이는 약어나 철자 손상보다 권장된다.\n(하지만 그렇지 않은 규칙도 있다.\n"),s("code",[t._v("'cls'")]),t._v("는 클래스를 나타내는 변수 또는 아규먼트,\n특히 클래스 메소드의 첫번째 아규먼트로도 바람직한 철자다.)")])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 1")]),t._v(" "),s("p",[t._v("위에 안내 된 클래스 메소드에서의 아규먼트 권장사항을 참고")])]),t._v(" "),s("ul",[s("li",[t._v("간단한 퍼블릭 데이터 어트리뷰트를 위해선\n단순히 어트리뷰트 명을 복잡한 접근자, 설정자(mutator) 없이 노출하는 것이 가장 좋다.\nPython 은 단순한 데이터 어트리뷰트가\n기능적 행위(functional behavior)을 확장해야하는 경우 ,\n향후 향상(enhancement)를 위한 쉬운 길을 제공하고 있다는 것을 명심하자.\n이러한 경우, 프로퍼티를 사용하여\n간단한 데이터 어트리뷰트 접근 구문 뒤에 기능 구현을 숨기자.")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 1")]),t._v(" "),s("p",[t._v("프로퍼티는 새로운 스타일의 클래스에서만 작동한다.")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 2")]),t._v(" "),s("p",[t._v("기능적 행위의 사이드 이펙트(side-effect)가 없도록 유지하도록 노력하자.\n하지만 캐싱과 같은 사이드 이펙트는 일반적으로 괜찮다.")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 3")]),t._v(" "),s("p",[t._v("계산적으로 비용이 높은 연산에 프로퍼티를 사용하는 것을 피하라\n어트리뷰트 표기법이 호출자(caller)의 접근\n비용이 (상대적으로) 낮음을 보장한다.")])]),t._v(" "),s("ul",[s("li",[t._v("하위 클래스로 의도된 클래스일 경우,\n그리고 하위 클래스에서 사용하지 않으려는 어트리뷰트가 있는 경우\n두개의 밑줄로 시작하여 후행 밑줄이 없는 작명법을 고려하자.\n이는 Python 의 이름 맹글링 알고리즘을 불러일으킨다.\n어트리뷰트가 위치한 클래스의 이름 또한 어트리뷰트 명으로 맹글된다.\n이는 하위클래스에 예기치 않게 같은 이름의 어트리뷰트가 포함된 경우\n어트리뷰트 명 충돌을 방지하는데 도움이 된다.")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 1")]),t._v(" "),s("p",[t._v("단순한 클래스("),s("em",[t._v("역: 여기서는 상속하지 않은 클래스")]),t._v(")의 이름만이 맹글된 이름에 사용되는 것을 주목하자.\n그렇기 때문에 만약 하위 클래스가 같은 클래스 명과 어트리뷰트 명을 선택할 경우,\n여전히 이름 충돌을 겪을 것이다.")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 2")]),t._v(" "),s("p",[t._v("이름 맹글링은 디버깅이나 "),s("code",[t._v("__gertattr__()")]),t._v(" 같은 특정 용도를\n더 불편하게 만들 수 있다. 하지만 이름 맹글링 알고리즘은 잘 문서화 되어있으며,\n메뉴얼하게 수행하기 쉽다.")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("안내 3")]),t._v(" "),s("p",[t._v("모두가 이름 맹글링을 좋아하는 것은 아니다."),s("br"),t._v("\n우발적인 이름 충돌을 방지하는 것과 고급 호출자("),s("em",[t._v("역: 여기서는 mangling 관련")]),t._v(")의\n잠재적인 사용 간의 균형을 맞추자.")])]),t._v(" "),s("h2",{attrs:{id:"퍼블릭-그리고-내부-인터페이스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#퍼블릭-그리고-내부-인터페이스"}},[t._v("#")]),t._v(" 퍼블릭 그리고 내부 인터페이스")]),t._v(" "),s("p",[t._v("이전 버전과의 호환성은 퍼블릭 인터페이스만 보장한다.\n따라서, 사용자가 퍼블릭 인터페이스와 내부 인터페이스를\n분명하게 구분할 수 있도록 하는 것이 중요하다.")]),t._v(" "),s("p",[t._v("문서화된 인터페이스는 퍼블릭으로 간주된다.\n문서에서 일반적으로 이전 버전과의 호환성 보장에서 제외되는\n임시(provisional) 또는 내부 인터페이스라고 명시적으로 선언하지 않는 한 말이다.\n모든 문서화되지 않은 인터페이스는 내부 인터페이스 간주된다.")]),t._v(" "),s("p",[t._v("더 나은 검사(introspection) 지원을 위해선,\n모듈은 퍼블릭 API 에서 "),s("code",[t._v("__all__")]),t._v(" 어트리뷰트를 사용함으로써 이름을 명시적으로 선언해야한다.\n"),s("code",[t._v("__all__")]),t._v("을 빈 리스트로 설정하는 것은 모듈이 퍼블릭 API 가 없음을 나타낸다.")]),t._v(" "),s("p",[s("code",[t._v("__all__")]),t._v(" 이 적절히 설정되었음에도 내부 인터페이스\n(패키지, 모듈, 클래스, 함수, 어트리뷰트나 다른 이름들)은\n첫글자만 밑줄인 단어를 사용해야한다.")]),t._v(" "),s("p",[t._v("인터페이스를 갖고 있는 네임스페이스(패키지, 모듈, 또는 클래스)가내부(internal)로 간주될 경우 또한\n내부 인터페이스로 간주된다.")]),t._v(" "),s("p",[t._v("불러오기된 이름은 구현 세부사항으로 항상 간주되어야 한다.\n이를 포함하는 모듈의 API의 명시적으로 문서화 된 부분이 아닌 한,\n다른 모듈들은 불러오기된 이름으로의 간접적인 접근에 의존하지 않아야한다.\n예를 들면 "),s("code",[t._v("os.path")]),t._v(" 나 패키지의 "),s("code",[t._v("__init__")]),t._v(" 모듈 같이\n하위 모듈로부터 기능이 노출된 API 말이다.")]),t._v(" "),s("hr",{staticClass:"footnotes-sep"}),t._v(" "),s("section",{staticClass:"footnotes"},[s("ol",{staticClass:"footnotes-list"},[s("li",{staticClass:"footnote-item",attrs:{id:"fn1"}},[s("p",[t._v("대문자. 예: "),s("code",[t._v("MyClass")]),t._v(" "),s("a",{staticClass:"footnote-backref",attrs:{href:"#fnref1"}},[t._v("↩︎")])])]),t._v(" "),s("li",{staticClass:"footnote-item",attrs:{id:"fn2"}},[s("p",[t._v("호출할 수 있는. 예: "),s("code",[t._v("my_class()")]),t._v(" "),s("a",{staticClass:"footnote-backref",attrs:{href:"#fnref2"}},[t._v("↩︎")])])]),t._v(" "),s("li",{staticClass:"footnote-item",attrs:{id:"fn3"}},[s("p",[s("a",{attrs:{href:"https://ko.wikipedia.org/wiki/%EB%B2%A1%ED%84%B0%EC%9D%98_%EA%B3%B5%EB%B3%80%EC%84%B1_%EB%B0%8F_%EB%B0%98%EB%B3%80%EC%84%B1",target:"_blank",rel:"noopener noreferrer"}},[t._v("위키피디아"),s("OutboundLink")],1),t._v(" "),s("a",{staticClass:"footnote-backref",attrs:{href:"#fnref3"}},[t._v("↩︎")])])]),t._v(" "),s("li",{staticClass:"footnote-item",attrs:{id:"fn4"}},[s("p",[t._v("모듈을 기준으로 public 이 아닌 것 "),s("a",{staticClass:"footnote-backref",attrs:{href:"#fnref4"}},[t._v("↩︎")])])]),t._v(" "),s("li",{staticClass:"footnote-item",attrs:{id:"fn5"}},[s("p",[t._v("대소문자 혼용. "),s("a",{staticClass:"footnote-backref",attrs:{href:"#fnref5"}},[t._v("↩︎")])])]),t._v(" "),s("li",{staticClass:"footnote-item",attrs:{id:"fn6"}},[s("p",[s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Name_mangling#:~:text=mangling%20%2D%20see%20above.-,Python,more%20than%20one%20trailing%20underscore.",target:"_blank",rel:"noopener noreferrer"}},[t._v("영문 위키피디아"),s("OutboundLink")],1),t._v(" "),s("a",{staticClass:"footnote-backref",attrs:{href:"#fnref6"}},[t._v("↩︎")])])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);